<!DOCTYPE html>
<!--
  TO DO:
  * Give a brief example of what do expect from the algorith. Show a 10x10
    matrice before and after algorithm
  * Compare the algorith to simply taking the average
  * Make a "fact" box in the introduction that explains what the algortihm does
    and doesn't do
-->

<html>
    <head>
        <meta charset="utf-8">
        <title>Learning Machine Learning</title>
        <!-- Including the font from google fonts -->
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300italic,300,600,400italic,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
        <!-- Including the libraries -->
        <script src="/libs/d3/d3.min.js"></script>
        <!-- libraries for the map -->
        <script src="/libs/d3.geo.projection.min.js"></script>
        <script src="/libs/topojson.js"></script>

        <!-- including the JS to make math look nice -->
        <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
        <!-- including script for code snippets -->
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=python&amp;skin=desert"></script>
        <!-- Including the CSS -->
        <link rel="stylesheet" href="/css/arcadetrail.css" media="screen" charset="utf-8">
        <link rel="stylesheet" href="/css/d3.geomap.css" media="screen" charset="utf-8">
    </head>

    <body>
            <h1> Learning Machine Learning</h1>
            <p>
              In this blog post we will implement a machine learning algorithm
              to recommend games to users based on the game they like owe and like.
              The data is from
              <a href="https://arcadetrail.com/upcoming"> www.arcadetrail.com </a> — check it
              out, its awesome.
            </p>
            <h2> About me </h2>
            <p>
              First a bit about my background. I’m currently a Ph.d.
              student in experimental physics and I have a master’s degree in
              mathematics and physics from the University of Roskilde. While I use
              <a href="http://se.mathworks.com/index.html?s_tid=gn_logo"> MatLab</a>
              every day for controlling experiments, analysing data and
              making pretty figures, I have had no formal training in computer science or
              any programming languages. All I know about MatLab I've learned though using the “help X”
              function in MatLab or through Googling “How to X in MatLab”. Over
              the last three years I have become quite efficient in MatLab, but
              I often run into problems where my fundamental knowledge about
              programming languages become dauntingly obvious.
            </p>
            <p>
              So before starting this Machine Learning project I had a firm understanding
              of mathematics and experience with numerical programming.
              In the beginning of January 2016 I decided to follow
              <a href="https://www.coursera.org/learn/machine-learning/">Coursera's
              Machine Learning course taught</a> by
              <a href="http://www.andrewng.org/"> Andrew Ng</a>. The course is
              excellent and I would reccomend it to anyone interesting in getting
              into machine learning. I found reccomender systems particularly
              interesting which is why I am writing about it now.
            </p>
            <h2> Introduction </h2>
            <p>
              This blogpost will be divided into three parts. In sections one I will
              go through the algorithm behind the reccomender system we will be
              building. If you are allready familiar with the collaborative filtering
              method you may wish to skim this part quickly. In the second section
              I will show how I built the reccomender system in Python. This was
              my first encounter with Python, so anyone new to Python may find
              it interesting. Anyone experience experience in Python my well cringe
              at ineffectiveness of my coding. In the thirs section I will reflect on
              what I've learned building this thing in Pythons focusing on the
              challanges I think other in similar positins will face.
            </p>
            <h2> A walkthough of the collaberative filtering method -
              The main ideas and the mathematics </h2>
            <p>
              Technically, the type of recommender system we will implement is
              called collaborative filtering. We will construct at Matrix with the
              size \( (# users)x(# games) \). This matrix
              contains all the votes for each user. At the time of writing this
              the Arcade trail database had 350 users and 4601 games, so \( R \)
              was a 350 by 4601 matrix. The matrix
              is incomplete in the sense that not every user will have voted for
              every game. The aim is to establish which games a user might like,
              that is, we will fill out the missing parts of the \(R\) matrix. We
              do this by finding the matrixes \( X \) and \( \Theta \) whose
              <a href="https://en.wikipedia.org/wiki/Matrix_multiplication"> (matrix)
                product </a> gives the filled out matrix \( R^* \):
              $$ \Theta X^T = R^* $$
              Here \( \Theta \) and \( X \)  are \(# users\) by 1 and \(# games\)
              by 1 matrices respectively. They have to be, otherwise the
              product would give \( R^* \) the wrong size.
            </p>
            <p>
              In principle this is all there is to it. Once you have your
              \( X \) and \( \Theta \) matrices you are done.
            </p>
            <p>
              To get the matrices \( X \) and \( \Theta \) we could simply try out
              numbers untill we hit ones with product that is reasonably close to
              \( R \). But this would be a tedious task even for quite small matrices.
              What we want is for the computer to do all
              the heavy lifting. For this we must come up with an mathematical expression
              that the computer can minimize. This is expression is usually called the cost
              function, presumably because it is the penalty the coomputer must
              pay for putting up a wrong answer. The cost function we will use
              is:
              $$ J(X,\Theta, R) =
              \frac{1}{2} \sum \left( \Theta X^T  - R \right)^{2} +
              \frac{\lambda}{2}\sum \Theta^{2}
              + \frac{\lambda}{2}\sum X^{2}
              $$
              Here \( A^2 \) is shorthand for squaring every entry in \( A \).
              That is \(A^2 = A \circ A \) and not \( A \cdot A \) or \( AA \)
              with \( \circ \) being is the symbol for the
              <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">
              entrywise product</a> and \( \cdot \) and the
              <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a>
              respectively.
            </p>
            <p>
              Lets look closer at what the cost function actually does. The first
              term is the squared difference between the prediction votes
              and the acutal votes. If the the difference is high the cost is high.
              The next two term are regularization terms. They are there to increase
              the cost of the using high values for the parameters. \( \lambda \)
              is a scalar we can chose freely, depending on how much we wish to
              supress high parameter values. If you use a very low value of \( \lambda
              \) chances are your optimization code will take ages to run and
              produce terribly results. So in the end the cost function produces a
              single number. If the cost is high, our computer did a bad job of
              reproducing \( R \).
            </p>
            <p>
              Since we are dealing with \( # user + # games \) parameters the
              optimizaing code need some extra help to run smoothly. This is done
              by supplying the gradient of the cost function. That is, we must
              know how much \( J \) changes when we change any one of the numbers
              in \( \Theta \) and \( X \).
            </p>
            <p>
              The gradient of \( X \) is given by:
              $$ X_{grad} =
              \left( \Theta X^T - R \right)\cdot \Theta
              + \lambda X $$
              While the gradient of \( \Theta \) is given by:
              $$ \Theta_{grad} =
              \left( \Theta X^T - R \right)\cdot X
              + \lambda \Theta $$
              Since the dot product produces a number (a scalar) \( X_{grad} \)
              and \( \Theta_{grad} \) have the same size as \( X \) and \( \Theta \)
              respectively. As, of course, they should.
            </p>
            <p>
              With the cost function and its gradient defined we can run the
              optimization code and get the \( \Theta \) and \( X \) matrices
              than are the used to calculate the reccomendations.
            </p>
            <p>
               To get the reccomendation for a specific user we simply need to
               do the following calculation:
              $$ r = \Theta_\text{user} X^T. $$
              This produces a matrix of size 1 by \( # games \) that include the
              probability (a number between 0 and 1) that the user would vote for
              each game. Getting the top ten reccomendations  ammounts
              to picking out the top ten values from \( r \).
            </p>
            <p>
              At the time of writing this, the reccomendation I get is:
              <ol>
                  <li>Mirror's Edge Catalyst</li>
                  <li>Portal</li>
                  <li>Cities Skylines: After Dark</li>
                  <li>Portal 2</li>
                  <li>Left 4 Dead 2</li>
                  <li>Counter-Strike: Source</li>
                  <li>Half-Life 2: Lost Coast</li>
                  <li>Half-Life 2</li>
                  <li>Uncharted 4 - A Thiefs End</li>
                  <li>Counter-Strike</li>
              </ol>
              Which is not half bad.
            </p>
            
    </body>
</html>

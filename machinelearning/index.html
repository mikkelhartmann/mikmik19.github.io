<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Learning Machine Learning</title>
        <!-- Including the font from google fonts -->
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300italic,300,600,400italic,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
        <!-- Including the libraries -->
        <script src="/libs/d3/d3.min.js"></script>
        <!-- libraries for the map -->
        <script src="/libs/d3.geo.projection.min.js"></script>
        <script src="/libs/topojson.js"></script>

        <!-- including the JS to make math look nice -->
        <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
        <!-- Including the CSS -->
        <link rel="stylesheet" href="/css/arcadetrail.css" media="screen" charset="utf-8">
        <link rel="stylesheet" href="/css/d3.geomap.css" media="screen" charset="utf-8">
    </head>

    <body>
            <h1> Learning Machine Learning </h1>
            <p>
              In this blog post we will implement a machine learning algorithm
              to recommend games to users based on the game they like owe and like.
              The data is from
              <a href="https://arcadetrail.com/upcoming"> www.arcadetrail.com </a> — check it
              out, its awesome.
            </p>
            <h2> Introduction </h2>
            <p>
              First a bit about my background. I’m currently a Ph.d.
              student in experimental physics and I have a master’s degree in
              mathematics and physics from the University of Roskilde. While I use
              <a href="http://se.mathworks.com/index.html?s_tid=gn_logo"> MatLab</a>
              every day for controlling experiments, analysing data and
              making pretty figures, I have had no formal training in computer science or
              any programming languages. All I know about MatLab I've learned though using the “help X”
              function in MatLab or through Googling “How to X in MatLab”. Over
              the last three years I have become quite efficient in MatLab, but
              I often run into problems where my fundamental knowledge about
              programming languages become dauntingly obvious.
            </p>
            <p>
              So before starting this Machine Learning project I had a firm understanding
              of mathematics and experience with numerical programming.
            </p>
            <p>
              In the beginning of January 2016 I decided to follow
              <a href="https://www.coursera.org/learn/machine-learning/">Coursera's
              Machine Learning course taught</a> by
              <a href="http://www.andrewng.org/"> Andrew Ng</a>.
            </p>
              This blogpost will be divided into three parts. In part one I will
              go through the algorithm behind the reccomender system we will be
              building. If you are allready familiar with the collaborative filtering
              method you may wish to skim this part quickly. In the second part
              I will show how I built the reccomender system in Python. This was
              my first encounter with Python, so anyone new to Python may find
              it interesting. Anyone experience experience in Python my well cringe
              at ineffectiveness of my coding. In the last part I will reflect on
              what I've learned building this thing in Pythons focusing on the
              challanges I think other in similar positins will face.
            </p>
            <h2> A walkthough of the collaberative filtering method -
              The main ideas and the mathematics </h2>
            <p>
              Technically, the type of recommender system we will implement is
              called collaborative filtering. We will construct at Matrix with the
              size \( (# users)x(# games) \). This matrix
              contains all the votes for each user. At the time of writing this
              the Arcade trail database had 350 users and 4601 games, so \( R \)
              was a 350 by 4601 matrix. The matrix
              is incomplete in the sense that not every user will have voted for
              every game. The aim is to establish which games a user might like,
              that is, we will fill out the missing parts of the \(R\) matrix. We
              do this by finding the matrixes \( X \) and \( \Theta \) whose
              <a href="https://en.wikipedia.org/wiki/Matrix_multiplication"> (matrix)
                product </a> gives the filled out matrix \( R^* \):
              $$ \Theta X^T = R^* $$
              Here \( \Theta \) and \( X \)  are \(# users\) by 1 and \(# games\)
              by 1 matrices respectively. They have to be, otherwise the
              product would give \( R^* \) the wrong size.
            </p>
            <p>
              In principle this is all there is to it.
            </p>
            <p>
              To get the matrices \( X \) and \( \Theta \) we could simply try out
              numbers untill we hit ones with product that is reasonably close to
              \( R \). But this would be a tedious task even for quite small matrices.
              What we want is for the computer to do all
              the heavy lifting. For this we must come up with an mathematical expression
              that the computer can minimize. This is expression is usually called the cost
              function, presumably because it is the penalty the coomputer must
              pay for putting up a wrong answer. The cost function we will use
              is:
              $$ J(X,\Theta, R) =
              \frac{1}{2} \sum \left( \Theta X^T  - R \right)^{2} +
              \frac{\lambda}{2}\sum \Theta^{2}
              + \frac{\lambda}{2}\sum X^{2}
              $$
              Here \( A^2 \) is shorthand for squaring every entry in \( A \).
              That is \(A^2 = A \circ A \) and not \( A \cdot A \) with \( \circ \)
              being is the symbol for the
              <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">
              entrywise product</a> and \( \cdot \) and the
              <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a>
              respectively.
            </p>
            <p>
              Lets look closer at what the cost function actually does. The first
              term is the squared difference between the prediction votes
              and the acutal votes. If the the difference is high the cost is high.
              The next two term are regularization terms. They are there to increase
              the cost of the using high values for the parameters. \( \lambda \)
              is a parameter we can chose freely, depending on how much we wish to
              supress high parameter values. If you use a very low value of \( \lambda
              \) chances are your optimization code will take ages to run and
              produce terribly results. So in the end the cost function produces a
              single number. If the cost is high, our computer did a bad job of
              reproducing \( R \).
            </p>
            <p>
              Since we are dealing with \( # user + # games \) parameters the
              optimizaing code need some extra help to run smoothly.
            </p>
            <p>
              The gradient of \( X \) is given by:
              $$ X_{grad} =
              \left[ \left( \Theta X^T - R \right)\circ R \right]\cdot \Theta
              + \lambda X $$
              While the gradient of \( \Theta \) is given by:
              $$ \Theta_{grad} =
               \left[ \left( \Theta X^T - R \right)\circ R \right]\cdot X
              + \lambda \Theta $$
              Again, here \( \circ \) is the symbol for the
              <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">
              entrywise product</a> and \( \cdot \) is the
              <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a>.
              Since the dot product produces a number (a scalar) \( X_{grad} \)
              and \( \Theta_{grad} \) have the same size as \( X \) and \( \Theta \)
              respectively. As, of course, they should.
            </p>
            <p>
              Supplying the optimization code with the cost function and the
              gradient it will find the best values for \( X \) and \( \Theta \).
              Once these vectors are obtained getting the top ten reccomendations
              for some user amounts to picking out the top ten values from the
              following vector:
              $$ r = \Theta (\text{# user}) X^T, $$
              At the time of writing this, the reccomendation I get is:
              <ol>
                  <li>Mirror's Edge Catalyst</li>
                  <li>Portal</li>
                  <li>Cities Skylines: After Dark</li>
                  <li>Portal 2</li>
                  <li>Left 4 Dead 2</li>
                  <li>Counter-Strike: Source</li>
                  <li>Half-Life 2: Lost Coast</li>
                  <li>Half-Life 2</li>
                  <li>Uncharted 4 - A Thiefs End</li>
                  <li>Counter-Strike</li>
              </ol>
              Which is not half bad.
            </p>
            <h2>The Python implementation</h2>
            <p>
              From Arcade Trail we have information about which games every user
              owns and votes for. From this we will construct our \( R \) matrix.
            </p>
            <h2>What remains to be done </h2>
            <p>
            Building this reccomender system was fun. However, there are a number
            of obvious improvements. For example, I know my older brother is not
            a big fan of first person shooters. Yet, on the list of reccomendations
            for him I find: Counter-Strike, Counter-Strike: Source,
            Counter-Strike: Condition Zero, Counter-Strike: Global Offensive and
            Half-Life 2: Deathmatch. Clearly the reccomender system would really
            like for him to try out Counter Strike.
          </p>
          <P>
            Luckily there is such a thing as a  content based reccomender
            system! This is what I will be playing with next.
          </p>
    </body>
</html>

<!DOCTYPE html>
<!--
  TO DO:
  * Give a brief example of what do expect from the algorith. Show a 10x10
    matrice before and after algorithm
  * Compare the algorith to simply taking the average
  * Make a "fact" box in the introduction that explains what the algortihm does
    and doesn't do
-->

<html>
    <head>
        <meta charset="utf-8">
        <title>Learning Machine Learning</title>
        <!-- Including the font from google fonts -->
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300italic,300,600,400italic,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
        <!-- Including the libraries -->
        <script src="/libs/d3/d3.min.js"></script>
        <!-- libraries for the map -->
        <script src="/libs/d3.geo.projection.min.js"></script>
        <script src="/libs/topojson.js"></script>

        <!-- including the JS to make math look nice -->
        <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
        <!-- including script for code snippets -->
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=python&amp;skin=desert"></script>
        <!-- Including the CSS -->
        <link rel="stylesheet" href="/css/arcadetrail.css" media="screen" charset="utf-8">
        <link rel="stylesheet" href="/css/d3.geomap.css" media="screen" charset="utf-8">
    </head>

    <body>
            <h1> Learning Machine Learning</h1>
            <h2>The Python implementation</h2>
            <p>
              Here I will go through my Python implementation of the collaberative
              filtering method.
            </p>
            <p>
              First I import all the packages I use.
            </p>
<pre class="prettyprint">
from numpy import *
import numpy as np
import operator
from os import listdir
import csv
import itertools
</pre>
          <p>
            Then I load the data. I have not included the code here since parsing
            functions are tedious to read and write. So lets move on to what happens
            after the data has been parsed into structures that Python understands.
            I construct the \( R \) matrix from the information we have about
            the users of Arcadetrail.com. We know which games they have voted
            on and which games they owe. I have chosen to count both votes and
            ownerships equally, and its doesn't matter if you have both voted for
            and owe a game -- it will only count once.
          </p>
<pre class="prettyprint">
def construct_R(votes,ownerships,num_users,num_games):
	R = zeros((num_users,num_games))
	for ii in range(0,len(votes)):
	    current_user = int(votes[ii,1])-1 #-1 because python starts at 0
	    current_game = int(votes[ii,0])-1
	    #print(current_user,current_game)
	    R[current_user,current_game] = 1
	# Filling up with user ownerships
	for ii in range(0,len(ownerships)):
	    current_user = int(ownerships[ii,1])-1
	    current_game = int(ownerships[ii,0])-1
	    R[current_user,current_game] = 1
	return R
</pre>
        <p>
          The code for the cost function is quite long -- this is the main reason
          why i prefer to write down all the equations on paper first. It is all
          too easy to loose track of the terms when writing the Python code.
        </p>
<pre class="prettyprint">
def cost_function(params, Y, R, num_users, num_games,num_features, regularization):
	X = np.reshape(params[0:num_games*num_features], (num_games, num_features))
	Theta = np.reshape(params[num_games*num_features:], (num_users, num_features))

	# calculating the prediction
	prediction = Theta * np.transpose(X)
	difference = ( prediction - Y )
	square_difference = np.multiply(difference,difference)
	square_difference_votes = np.multiply(square_difference,R)

	theta_squared = np.multiply(Theta,Theta)
	theta_regularized = (regularization/2)*sum(theta_squared)

	X_squared = np.multiply(X,X)
	X_regularized = (regularization/2)*sum(X_squared)

	cost = 0.5* sum(square_difference_votes) + theta_regularized + X_regularized
	return cost
</pre>
          <p>
            Calculating the gradient of the cost function.
          </p>
<pre class="prettyprint">
def cost_grad(params, Y, R, num_users, num_games,num_features, regularization):
  X = np.reshape(params[0:num_games*num_features], (num_games, num_features))
  Theta = np.reshape(params[num_games*num_features:], (num_users, num_features))

  # calculating X_grad
  prediction = Theta*np.transpose(X)
  difference = prediction - Y
  voted = np.multiply(difference,R)
  X_grad = np.dot(np.transpose(voted),Theta) + regularization*X

  # calculating Theta_grad
  Theta_grad = np.dot(voted,X) + regularization*Theta

  # rolling paramaters out
  grad = np.append(X_grad,Theta_grad)
  return(grad)
</pre>
          <p>
            The code for getting the \( \Theta \) and \( X \) matrices is mainly running the
            fmin_cg function from scipy library. The rest of the code is just reshaping the
            \( \Theta \) and \( X \) matrices into a single vector to simplify the optimization
            and then putting them back to their natural size when then optimization is done.
          </p>
<pre class="prettyprint">
  def collaberative_filtering(num_games,num_users,num_features,R,regularization):
  	import scipy.optimize
  	import ReccomenderSystem
  	X = np.random.randint(2,size=(num_games,num_features))
  	Theta = np.random.randint(2,size=(num_users,num_features))

  	X_long = np.reshape(X,(size(X),1))
  	Theta_long = np.reshape(Theta,size(Theta),1)
  	initial_parameters = np.append(X_long,Theta_long)

  	Y = R

  	# doing the actual fitting
  	params = scipy.optimize.fmin_cg(
  	    f = ReccomenderSystem.cost_function,
  	    x0 = initial_parameters,
  	    fprime = ReccomenderSystem.cost_grad,
  	    args=(Y, R, num_users, num_games,num_features, regularization),
  	    maxiter=200)

  	# Rolling the fitted parameters back into X and Theta
  	X = np.reshape(params[0:num_games*num_features], (num_games, num_features))
  	Theta = np.reshape(params[num_games*num_features:], (num_users, num_features))
  	return X, Theta
</pre>
          <p>
            Now we have all we need to reccomend games to user! The following function gets
            the reccomendations for a user specified by the user id.
          </p>
<pre class = "prettyprint">
def getting_reccomendations(R,Theta,X,titles,user_names,user_id):
	user_index = user_id-1 # Fixing the indexing
	prediction = Theta * np.transpose(X)
	reccomendations = prediction[user_index,:]
	# removing from the list of reccomandations games the user allready likes
	to_remove = np.where(R[user_index,:]==1)
	reccomendations[to_remove] = 0

	# sorting the list of reccomendations
	sortIndex = sorted(range(len(reccomendations)), key=lambda k: reccomendations[k],reverse=True)

	# finding the user name
	user_names = np.matrix(user_names)
	name_index = np.where(user_names[:,0]==str(user_id))
	name_index = int(name_index[0])
	name = user_names[name_index,1]

	titles = np.matrix(titles)

	# printing the top 10 reccomendations
	print 'The top 10 reccomendations for %s' % name + ' (user_id %s' % str(user_index+1) +')'
	for i in range(0,10,1):#range(10):
	    title_index = np.where(titles[:,0]==str(sortIndex[i]+1))
	    print(i+1, titles[title_index[0][0],1])
</pre>
          <p>
            This concludes the Python implementation of the collaberative filtering
            reccomender system.
          </p>
    </body>
</html>
